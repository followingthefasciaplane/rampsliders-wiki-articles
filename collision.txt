// https://rampsliders.wiki/doku.php?id=technical:collision

==== Source Engine Collision System ====

The **Source Engine** is renowned for its robust and efficient collision detection system, a cornerstone for realistic and responsive gameplay. This system meticulously manages interactions between entities, the environment, and players, ensuring both performance and precision. \\

This article delves into the intricacies of the Source Engine's collision system, providing a comprehensive guide for new developers aiming to understand and leverage its capabilities.

----

==== Table of Contents ====
  * Overview
  * Core Components
    * Static World Collision (Brush Models)
    * Dynamic Collision (VPhysics Models)
    * Displacement Collision
    * Collision Properties
  * Collision Representations
    * Brushes (''cbrush_t'')
    * Box Brushes (''cboxbrush_t'')
    * Collision Models (''cmodel_t'')
    * Displacement Trees (''CDispCollTree'')
  * Solid Types and Flags
    * Solid Types
    * Contents Flags
    * Surface Flags
  * Spatial Partitioning and BSP Trees
    * BSP Trees (''cnode_t'', ''cleaf_t'')
    * Spatial Partitioning (''CCollisionBSPData'')
  * Collision Detection Methods
    * Trace System Architecture
    * Ray Tracing (''Ray_t'')
    * Box Tracing
    * Sphere Tracing
    * Oriented Bounding Box (OBB) Tracing
    * Engine Trace Implementation Details
      * Trace Filter Hierarchy 
      * Mailbox Optimization System
      * SIMD-Optimized Ray Processing
      * Trace Stream Processing
      * Debug Visualization Support
  * Collision Masks
    * Mask Definitions
    * Practical Usage
  * Collision System Workflow
    * Initialization
    * Entity Setup
    * Spatial Partitioning
    * Collision Queries
    * Result Handling
  * Optimization Techniques
    * BSP Trees
    * Spatial Partitioning
    * Trace Caching
    * Bit Packing
    * SIMD-Optimized Collision Tests
  * Advanced Topics
    * Content Type System
    * Displacement Collision System
    * Spatial Partition System
  * Conclusion
  * References

----

==== Overview ====

Collision detection in the Source Engine ensures that entities within the game world interact seamlessly, whether it's a player navigating through a complex environment, a bullet hitting a target, or dynamic objects responding to forces. \\

The system balances accuracy with performance, employing various data structures and algorithms to handle static and dynamic collisions efficiently.

----

==== Core Components ====

The collision system is modular, with each component handling specific aspects of collision detection and response.

----

=== Static World Collision (Brush Models) ===

Static world collision pertains to the non-moving geometry of the game environment, such as walls, floors, and other architectural elements. These are defined using **brush models**, which are convex shapes constructed from planes.

**Brushes (''cbrush_t'')**: 
  * Represent basic convex shapes. 
  * Each brush consists of multiple sides (''cbrushside_t''), each defined by a plane. 
  * Brushes are the building blocks of the static environment.

**Box Brushes (''cboxbrush_t'')**: 
  * Optimized representations for axis-aligned bounding boxes (AABB). 
  * When a brush is a simple box, it is stored as a ''cboxbrush_t'' to enhance performance and reduce memory usage.

<code cpp>
struct cbrush_t {
    int contents;            // Defines the collision behavior based on contents flags.
    unsigned short numsides; // Number of sides in the brush.
    unsigned short firstbrushside; // Index to the first side in the brush.
    
    inline bool IsBox() const { return numsides == NUMSIDES_BOXBRUSH; }
};
</code>

**Collision Characteristics**:
  * Optimized for static geometry.
  * Cannot represent concave shapes directly (handled by breaking down into convex components).
  * Stores per-side surface properties for different behaviors during collision response.

----

=== Dynamic Collision (Physics Models) ===

Dynamic collisions involve entities that can move, rotate, or interact physically with the environment and other entities. The physics system handles these interactions, providing realistic physics simulations.

**Collision Models (''cmodel_t'')**: 
  * Define the physical properties of dynamic entities, including their bounding boxes, origin, and associated physics data.
  
**Physics Integration**: 
  * Dynamic models integrate with the VPhysics system (''IPhysicsCollision''), allowing entities to respond to forces, collisions, and other physical interactions.

<code cpp>
struct cmodel_t {
    Vector mins, maxs;           // Axis-Aligned Bounding Box (AABB).
    Vector origin;               // Local origin of the model.
    int headnode;                // Index to the BSP tree node.
    vcollide_t vcollisionData;   // VPhysics collision data.
};
</code>

**Features**:
  * Suitable for entities that transform (move, rotate).
  * Integrates with physics to handle real-world dynamics, including gravity, mass, and collisions with other dynamic objects.
  * Models are represented as a hierarchy of collision components, allowing efficient management of complex shapes.

----

=== Displacement Collision ===

**Displacements** are specialized for handling complex, deformable terrains like hills, ramps, and slopes. They allow for smooth and varied terrain shapes beyond simple convex brushes.

**Displacement Trees (''CDispCollTree'')**: 
  * Manage the collision data for displacements, including a hierarchical bounding volume (AABB) and detailed mesh data for precise collision detection.
  
**Surface Properties**: 
  * Each triangle within a displacement can have unique surface properties, enabling diverse interactions such as varying friction or slipperiness.

**Key Features**:
  * Hierarchical AABB tree for broad-phase testing.
  * Efficient triangle intersection for detailed collision.
  * Surface property support for physics simulation.

----

=== Collision Properties ===

Each entity in the Source Engine has a **CCollisionProperty** instance that defines how it interacts with other entities. This system enables detailed control over solid types, spatial transformations, and specific behaviors for each entity.

**Key Responsibilities**:
  * **Bounding Boxes**: Defines both pre-scaled and scaled bounding boxes to accommodate entity transformations.
    
  * **Solid Types**: Determines how the entity interacts with others (e.g., solid, non-solid, trigger).
    
  * **Spatial Partitioning**: Integrates with the spatial partitioning system to optimize collision checks by organizing entities within spatial bounds.
    
  * **Transformations**: Handles the conversion between entity space and world space for accurate collision detection.

----

==== Collision Representations ====

Collision representations define the physical shapes used in collision detection. They range from simple bounding boxes to complex meshes.

----

=== Brushes (''cbrush_t'') ===

Brushes are the simplest collision primitives, representing convex volumes defined by multiple planes. They form the static geometry of the game world.

<code cpp>
struct cbrush_t {
    int contents;            // Collision behavior flags.
    unsigned short numsides; // Number of sides.
    unsigned short firstbrushside; // Index to the first side.
    
    inline bool IsBox() const { return numsides == NUMSIDES_BOXBRUSH; }
};
</code>

**Contents Flags**: Determine how the brush interacts with different collision masks and entities.

----

=== Box Brushes (''cboxbrush_t'') ===

When a brush is a simple axis-aligned box, it is optimized into a ''cboxbrush_t'', which reduces computational overhead during collision checks.

<code cpp>
struct cboxbrush_t {
    VectorAligned mins;
    VectorAligned maxs;
    unsigned short surfaceIndex[6]; // Indices to surface properties.
    unsigned short pad2[2];         // Padding for alignment.
};
</code>

**Optimized Representation**:
  * Box brushes allow for faster intersection tests due to their predictable geometry.
  * Reduced memory footprint compared to standard brushes.

----

=== Collision Models (''cmodel_t'') ===

Dynamic entities use ''cmodel_t'' structures to define their collision boundaries and physical properties.

<code cpp>
struct cmodel_t {
    Vector mins, maxs;           // AABB.
    Vector origin;               // Local origin.
    int headnode;                // BSP node index.
    vcollide_t vcollisionData;   // VPhysics data.
};
</code>

**Integration with VPhysics**: Enables dynamic responses to forces and interactions, such as pushing objects or reacting to explosions.

----

=== Displacement Trees (''CDispCollTree'') ===

Displacements handle more intricate terrain shapes, providing detailed collision data for uneven surfaces.

<code cpp>
class CDispCollTree {
public:
    bool AABBTree_Ray(const Ray_t &ray, const Vector &invDelta, trace_t *pTrace);
    bool AABBTree_SweepAABB(const Ray_t &ray, const Vector &invDelta, trace_t *pTrace);
    
    // Triangle collision data
    Vector m_mins;           // AABB mins
    Vector m_maxs;           // AABB maxs
    int m_power;            // Subdivision power
    int m_contents;         // Surface contents
    unsigned short m_surfaceProps[2]; // Surface properties
};
</code>

**Key Features**:
  * **Hierarchical AABB Tree**: Facilitates efficient broad-phase collision detection by organizing collision data hierarchically.
    
  * **Triangle Collision**: Precise collision detection using triangle meshes within displacements.
    
  * **Surface Properties**: Each triangle can have unique properties, affecting physics interactions like friction and restitution.

----

==== Solid Types and Flags ====

Solid types and flags define the fundamental collision behaviors of entities and surfaces.

----

=== Solid Types ===

Solid types categorize entities based on their collision characteristics, influencing how they interact with other entities and the environment.

<code cpp>
enum SolidType_t {
    SOLID_NONE = 0,        // No collision.
    SOLID_BSP,             // Static BSP geometry.
    SOLID_BBOX,            // Axis-Aligned Bounding Box.
    SOLID_OBB,             // Oriented Bounding Box.
    SOLID_CUSTOM,          // Custom collision handling.
    SOLID_VPHYSICS         // Physics-based collision.
};
</code>

**Description of Solid Types**:
  * **SOLID_NONE**: Entity is non-collidable, allowing free movement through it.
  * **SOLID_BSP**: Integrates with the BSP tree for static world geometry, suitable for immovable structures.
  * **SOLID_BBOX**: Uses an AABB for simple collision detection, ideal for axis-aligned entities.
  * **SOLID_OBB**: Utilizes an OBB for rotated entities, providing accurate collision handling for non-axis-aligned objects.
  * **SOLID_CUSTOM**: Allows for bespoke collision responses, useful for entities requiring unique interaction behaviors.
  * **SOLID_VPHYSICS**: Engages the VPhysics system for dynamic interactions, handling forces, mass, and realistic physical responses.

----

=== Contents Flags ===

Contents flags specify the physical properties of regions and surfaces, determining how they interact with various collision masks and entities.

<code cpp>
#define CONTENTS_EMPTY          0x0
#define CONTENTS_SOLID          0x1
#define CONTENTS_WINDOW         0x2
#define CONTENTS_AUX            0x4
#define CONTENTS_GRATE          0x8
#define CONTENTS_SLIME          0x10
#define CONTENTS_WATER          0x20
#define CONTENTS_BLOCKLOS       0x40
#define CONTENTS_OPAQUE         0x80
#define CONTENTS_TESTFOGVOLUME  0x100
#define CONTENTS_UNUSED         0x200
#define CONTENTS_TEAM1          0x800
#define CONTENTS_TEAM2          0x1000
#define CONTENTS_IGNORE_NODRAW_OPAQUE 0x2000
#define CONTENTS_MOVEABLE       0x4000
#define CONTENTS_AREAPORTAL     0x8000
#define CONTENTS_PLAYERCLIP     0x10000
#define CONTENTS_MONSTERCLIP    0x20000
#define CONTENTS_CURRENT_0      0x40000
#define CONTENTS_CURRENT_90     0x80000
#define CONTENTS_CURRENT_180    0x100000
#define CONTENTS_CURRENT_270    0x200000
#define CONTENTS_CURRENT_UP     0x400000
#define CONTENTS_CURRENT_DOWN   0x800000
#define CONTENTS_ORIGIN         0x1000000
#define CONTENTS_MONSTER        0x2000000
#define CONTENTS_DEBRIS         0x4000000
#define CONTENTS_DETAIL         0x8000000
#define CONTENTS_TRANSLUCENT    0x10000000
#define CONTENTS_LADDER         0x20000000
#define CONTENTS_HITBOX         0x40000000
</code>

**Key Flags**:
  * **CONTENTS_SOLID**: Completely solid; entities cannot pass through.
  * **CONTENTS_WATER**: Defines water areas affecting movement and physics.
  * **CONTENTS_GRATE**: Special surfaces allowing partial passage (e.g., bullets pass through but not players).
  * **CONTENTS_HITBOX**: Used for precise hit detection on entities.
  * **CONTENTS_BLOCKLOS**: Blocks AI line of sight.
  * **CONTENTS_MOVEABLE**: Indicates that the object can be moved, affecting physics interactions.

**Usage**:
  * **Collision Masks**: These flags are combined into masks that determine which surfaces are considered during collision checks.
  * **Layered Interactions**: Multiple flags can be set on a single brush to define complex interactions (e.g., a window surface is both ''CONTENTS_SOLID'' and ''CONTENTS_WINDOW'').

----

=== Surface Flags ===

Surface flags provide additional metadata about individual surfaces within collision models, influencing rendering and collision responses.

<code cpp>
#define SURF_LIGHT       0x0001
#define SURF_SKY2D       0x0002
#define SURF_SKY         0x0004
#define SURF_WARP        0x0008
#define SURF_TRANS        0x0010
#define SURF_NOPORTAL    0x0020
#define SURF_TRIGGER     0x0040
#define SURF_NODRAW      0x0080
#define SURF_HINT        0x0100
#define SURF_SKIP        0x0200
#define SURF_NOLIGHT     0x0400
#define SURF_BUMPLIGHT   0x0800
#define SURF_NOSHADOWS   0x1000
#define SURF_NODECALS    0x2000
#define SURF_NOCHOP      0x4000
#define SURF_HITBOX      0x8000
</code>

**Key Flags**:
  * **SURF_SKY**: Marks surfaces as part of the skybox; they do not render traditional textures.
  * **SURF_WARP**: Indicates surfaces with visual warping effects, like water.
  * **SURF_NODRAW**: Surfaces that should not be rendered.
  * **SURF_HITBOX**: Surfaces used for precise hit detection.
  * **SURF_NOPORTAL**: Prevents portals from being placed on the surface.
  * **SURF_NODECALS**: Prevents decals from being applied to the surface.
  
**Usage**:
  * **Rendering**: Flags like ''SURF_SKY'' and ''SURF_WARP'' influence how surfaces are rendered.
  * **Collision Response**: Flags like ''SURF_HITBOX'' affect collision detection precision and behavior.

----

==== Spatial Partitioning and BSP Trees ====

Efficient collision detection is paramount, especially in complex environments. The Source Engine employs **Binary Space Partitioning (BSP) trees** and **spatial partitioning** to optimize collision queries.

----

=== BSP Trees (cnode_t, cleaf_t) ===

BSP trees divide the game world into convex regions (leaves), allowing the engine to quickly eliminate large areas from collision checks.

<code cpp>
struct cnode_t {
    cplane_t *plane;          // Splitting plane.
    int children[2];          // Child nodes; negative indices indicate leaf nodes.
};

struct cleaf_t {
    int contents;             // Contents flags for the leaf.
    short cluster;            // Visibility cluster.
    short area : 9;
    short flags : 7;
    unsigned short firstleafbrush;
    unsigned short numleafbrushes;
    unsigned short dispListStart;
    unsigned short dispCount;
};
</code>

**Nodes (''cnode_t'')**: Contain splitting planes and references to child nodes, facilitating recursive traversal during collision queries.
  
**Leaves (''cleaf_t'')**: Store contents flags and references to brushes occupying that region.

**Advantages**:
  * **Efficient Traversal**: Quickly narrows down potential collision areas by traversing the BSP tree.
  * **Memory Efficiency**: Reduces redundant storage of collision data by organizing it hierarchically.

**Traversal Example**:
  * **Collision Query**: When performing a collision check, the engine traverses the BSP tree, testing the ray or volume against the splitting planes to determine which child nodes (or leaves) need to be checked.

----

=== Spatial Partitioning (CCollisionBSPData) ===

The ''CCollisionBSPData'' class encapsulates all BSP-related data necessary for collision detection, including nodes, leaves, brushes, and displacement trees.

<code cpp>
class CCollisionBSPData {
public:
    cnode_t *map_rootnode;
    char map_name[MAX_QPATH];
    static csurface_t nullsurface;
    
    // Arrays for brushes, planes, nodes, leaves, etc.
    CRangeValidatedArray<cbrushside_t> map_brushsides;
    CRangeValidatedArray<cboxbrush_t> map_boxbrushes;
    CRangeValidatedArray<cplane_t> map_planes;
    CRangeValidatedArray<cnode_t> map_nodes;
    CRangeValidatedArray<cleaf_t> map_leafs;
    // ... additional members ...
    
    csurface_t *GetSurfaceAtIndex(unsigned short surfaceIndex);
};
</code>

**Data Management**: Handles the loading, destruction, and management of BSP data.
  
**Visibility and Area Portals**: Manages visibility data and area portals to optimize collision checks based on what is visible or accessible.

**Global Collision Data**: Maintains global collision data accessible throughout the engine, ensuring consistent collision handling across different systems.

----

==== Collision Detection Methods and Tracing ====

The Source Engine employs various collision detection techniques to handle different interaction scenarios effectively. The trace system is a pivotal component of the collision system, responsible for performing collision checks and managing trace states.

----

=== TraceInfo_t Structure ===

The trace system utilizes a sophisticated tracking structure to manage collision state.

<code cpp>
struct TraceInfo_t {
    trace_t m_trace;              // Current trace result
    Vector m_start;               // Starting point
    Vector m_end;                 // End point
    Vector m_mins;                // Minimum extents
    Vector m_maxs;                // Maximum extents
    Vector m_extents;             // Extents cache
    Vector m_delta;               // Movement vector
    Vector m_invDelta;            // Inverse delta for optimization
    bool m_isPoint;               // True if tracing a point
    bool m_isSwept;               // True if trace is swept
    TraceCounter_t *m_pBrushCounters;
    int m_contents;               // Contents mask being traced against
    
    bool Visit(const cbrush_t *pBrush, int ndxBrush, 
               TraceCounter_t count, TraceCounter_t *pCounters);
};
</code>

**Key Components**:
  * **Trace State Tracking**: Maintains the state of the current trace, including start and end points, extents, and movement vectors.
  * **Collision Detection Optimization**: Utilizes inverse deltas and extents caching to optimize collision calculations.
  * **Visit Tracking**: Prevents redundant collision checks by tracking which brushes and surfaces have already been visited during a trace.

**Visit Functionality**:
  * **Purpose**: Ensures that each brush or displacement surface is only checked once per trace, improving performance by avoiding unnecessary calculations.
  * **Implementation**: Compares the current trace count with cached counters to determine if a brush has already been processed.

<code cpp>
inline bool TraceInfo_t::Visit(const cbrush_t *pBrush, int ndxBrush, 
                               TraceCounter_t count, TraceCounter_t *pCounters) {
    TraceCounter_t *pCounter = pCounters + ndxBrush;

    if (*pCounter == count) {
        return false;
    }

    *pCounter = count;
    return true;
}
</code>

----

=== Ray Tracing (Ray_t) ===

**Ray Tracing** is a fundamental technique used for line-of-sight checks, bullet trajectories, and interaction tracing. A ray is defined by a start point, direction, and optional extents for swept volumes.

<code cpp>
struct Ray_t {
    VectorAligned m_Start;        // Starting point.
    VectorAligned m_Delta;        // Direction and length.
    VectorAligned m_StartOffset;  // Offset for swept rays.
    VectorAligned m_Extents;      // Extents for swept volumes.
    bool m_IsRay;                 // True if no extents.
    bool m_IsSwept;               // True if delta is non-zero.

    void Init(const Vector &start, const Vector &end) {
        VectorSubtract(end, start, m_Delta);
        m_IsSwept = (m_Delta.LengthSqr() != 0);
        VectorClear(m_Extents);
        m_IsRay = true;
        VectorClear(m_StartOffset);
        VectorCopy(start, m_Start);
    }

    void Init(const Vector &start, const Vector &end, const Vector &mins, const Vector &maxs) {
        VectorSubtract(end, start, m_Delta);
        m_IsSwept = (m_Delta.LengthSqr() != 0);
        VectorSubtract(maxs, mins, m_Extents);
        m_Extents *= 0.5f;
        m_IsRay = (m_Extents.LengthSqr() < 1e-6);
        VectorAdd(mins, maxs, m_StartOffset);
        m_StartOffset *= 0.5f;
        VectorAdd(start, m_StartOffset, m_Start);
        m_StartOffset *= -1.0f;
    }

    Vector InvDelta() const {
        Vector vecInvDelta;
        for (int iAxis = 0; iAxis < 3; ++iAxis) {
            vecInvDelta[iAxis] = (m_Delta[iAxis] != 0.0f) ? 1.0f / m_Delta[iAxis] : FLT_MAX;
        }
        return vecInvDelta;
    }
};
</code>

**Initialization**:
  * **Simple Ray**: Defined by start and end points.
  * **Swept Ray**: Includes extents, allowing for swept volume tracing.

**Inverse Delta Calculation**:
  * **Purpose**: Optimizes intersection calculations by precomputing reciprocal values of the delta vector.
  * **Usage**: Facilitates faster collision detection by reducing division operations during trace execution.

----

==== Engine Trace Implementation Details ====

This section provides deeper technical insight into the Source Engine's collision system implementation, focusing on trace filtering, optimization systems, and debugging support.

----

=== Trace Filter Hierarchy ===

The Source Engine implements a sophisticated filter hierarchy for collision traces, allowing fine-grained control over what entities participate in collision tests.

<code cpp>
class CTraceFilterSimple : public CTraceFilter {
public:
    CTraceFilterSimple(const IHandleEntity *passentity, int collisionGroup, 
                      ShouldHitFunc_t pExtraShouldHitCheckFn = NULL);
    virtual bool ShouldHitEntity(IHandleEntity *pHandleEntity, int contentsMask);
    
private:
    const IHandleEntity *m_pPassEnt;
    int m_collisionGroup;
    ShouldHitFunc_t m_pExtraShouldHitCheckFunction;
};

class CTraceFilterSkipTwoEntities : public CTraceFilterSimple {
public:
    CTraceFilterSkipTwoEntities(const IHandleEntity *passentity, 
                               const IHandleEntity *passentity2, 
                               int collisionGroup);
    virtual bool ShouldHitEntity(IHandleEntity *pHandleEntity, int contentsMask);
    
private:
    const IHandleEntity *m_pPassEnt2;
};
</code>

**Filter Types and Usage**:

  * **CTraceFilterSimple**: Basic filter for skipping a single entity
    * Used for self-collision prevention
    * Supports collision group filtering
    * Optional custom hit check function

  * **CTraceFilterSkipTwoEntities**: Extended filter for skipping two entities
    * Common in weapon traces (skip both player and weapon)
    * Inherits collision group behavior

  * **Custom Filters**: Game-specific implementations
    * LOS (Line of Sight) specific filters
    * Team-based collision filters
    * Special gameplay mechanic filters

----

=== Mailbox Optimization System ===

The engine employs a mailbox system to prevent redundant collision tests against the same brush or entity within a single trace.

<code cpp>
// From enginetrace.cpp
#define MAILBOX_HASH_SIZE 256

struct TraceInfo_t {
    // ... other members ...
    
    bool Visit(int brushIndex) {
        TraceCounter_t *pCounter = GetBrushCounters() + brushIndex;
        if (*pCounter == GetCount()) {
            return false;  // Already tested this brush
        }
        *pCounter = GetCount();
        return true;
    }
};
</code>

**Key Features**:
  * Hash-based lookup for quick redundancy checks
  * Per-trace counters to avoid clearing arrays
  * Separate tracking for brushes and displacements

----

=== SIMD-Optimized Ray Processing ===

The engine processes multiple rays simultaneously using SIMD operations for improved performance.

<code cpp>
struct FourRays {
    FourVectors origin;
    FourVectors direction;

    int CalculateDirectionSignMask(void) const {
        // Efficiently compute sign mask for all components
        int ret;
        int32 const *treat_as_int = ((int32 const *) (&direction));
        
        // Compute masks through bitwise operations
        int ormask = andmask = *(treat_as_int++);
        ormask |= *treat_as_int;
        andmask &= *(treat_as_int++);
        // ... additional mask computations ...
        
        return ret;
    }
};

// Ray batch processing
void RayTracingEnvironment::Trace4Rays(const FourRays &rays, 
                                     fltx4 TMin, fltx4 TMax,
                                     RayTracingResult *rslt_out) {
    // Process four rays in parallel using SIMD
    FourVectors OneOverRayDir = rays.direction;
    OneOverRayDir.MakeReciprocalSaturate();
    
    // Perform SIMD-optimized bounding box tests
    for(int c=0; c<3; c++) {
        fltx4 isect_min_t = MulSIMD(
            SubSIMD(ReplicateX4(m_MinBound[c]), rays.origin[c]), 
            OneOverRayDir[c]
        );
        // ... additional SIMD computations ...
    }
}
</code>

**Optimization Techniques**:
  * Parallel processing of four rays
  * SIMD-optimized vector operations
  * Efficient sign mask computation
  * Pre-computed reciprocals for division avoidance

----

=== Trace Stream Processing ===

The engine supports efficient batch processing of multiple rays through a stream interface.

<code cpp>
struct RayStream {
    FourRays PendingRays[8];           // Ray batches by direction signs
    int n_in_stream[8];                // Count per direction category
    RayTracingSingleResult *PendingStreamOutputs[8][4];  // Results storage
};

void RayTracingEnvironment::AddToRayStream(RayStream &s,
                                         Vector const &start,
                                         Vector const &end,
                                         RayTracingSingleResult *rslt_out) {
    Vector delta = end - start;
    int msk = GetSignMask(delta);      // Categorize ray by direction
    int pos = s.n_in_stream[msk];
    
    // Add to appropriate batch
    s.PendingRays[msk].origin[pos] = start;
    s.PendingRays[msk].direction[pos] = delta;
    s.PendingStreamOutputs[msk][pos] = rslt_out;
    
    // Process batch if full
    if (pos == 3) {
        FlushStreamEntry(s, msk);
    } else {
        s.n_in_stream[msk]++;
    }
}
</code>

**Stream Processing Benefits**:
  * Efficient batching of similar rays
  * Reduced instruction overhead
  * Better cache utilization
  * Automatic SIMD optimization

----

=== Debug Visualization Support ===

The engine includes comprehensive debugging support for collision traces.

<code cpp>
ConVar debugrayenable("debugrayenable", "0", NULL, "Enable ray visualization");
ConVar debugraylimit("debugraylimit", "500", NULL, "Rays per frame limit");

void DebugDrawLine(const Vector& start, const Vector& end, 
                  int r, int g, int b, bool test, float duration) {
    // Visualization implementation
}

void UTIL_TraceLine(const Vector& vecAbsStart, const Vector& vecAbsEnd, 
                   unsigned int mask, const IHandleEntity *ignore, 
                   int collisionGroup, trace_t *ptr) {
    // ... trace implementation ...
    
    if(r_visualizetraces.GetBool()) {
        DebugDrawLine(ptr->startpos, ptr->endpos, 
                     255, 0, 0, true, -1.0f);
    }
}
</code>

**Debugging Features**:
  * Real-time trace visualization
  * Configurable trace limits
  * Color-coded collision types
  * Duration-based persistence

----

=== Box Tracing ===

**Box Tracing** detects collisions involving axis-aligned or oriented bounding boxes (AABB/OBB). It is essential for player movement, object interactions, and environmental collisions.

* **Functionality**: Determines if and where a box intersects with the environment or other entities.
  
* **Usage**: Commonly used in character movement systems to prevent clipping through walls and other obstacles.

<code cpp>
bool IsBoxIntersectingRay(const fltx4& boxMin, const fltx4& boxMax,
                         const fltx4& origin, const fltx4& delta,
                         const fltx4& invDelta, const fltx4& vTolerance)
{
    // SIMD-optimized intersection test between a box and a ray
    // Implementation details...
}
</code>

**Key Features**:
  * **Axis-Aligned and Oriented Boxes**: Supports both AABB and OBB, providing flexibility in collision detection.
  * **SIMD Optimization**: Utilizes Single Instruction, Multiple Data (SIMD) instructions for parallel computations, enhancing performance.

----

=== Sphere Tracing ===

**Sphere Tracing** handles collisions involving spherical volumes, useful for proximity checks, explosion radii, and area-of-effect interactions.

**Functionality**: Detects intersections between a moving sphere and static or dynamic objects.
  
**Usage**: Implemented in features like grenade explosions, where the affected area is spherical.

<code cpp>
bool IntersectRayWithSphere(const Vector &vecRayOrigin, const Vector &vecRayDelta, 
                            const Vector &vecSphereCenter, float flRadius, 
                            float *pT1, float *pT2);
</code>

**Key Features**:
  * **Precise Collision Detection**: Ensures accurate interaction between spherical volumes and other collision representations.
  * **Optimization**: Utilizes mathematical optimizations to minimize computational overhead during intersection tests.

----

=== Oriented Bounding Box (OBB) Tracing ===

**OBB Tracing** accounts for entities that are rotated or have non-axis-aligned bounding boxes, providing precise collision detection for such objects.

**Functionality**: Transforms the ray into the OBB's local space to perform collision checks, then transforms the results back to world space.
  
**Usage**: Essential for accurately detecting collisions with rotated objects like doors, barrels, and other dynamic entities.

<code cpp>
bool IntersectRayWithOBB(const Ray_t &ray, const Vector &vecBoxOrigin, 
                         const QAngle &angBoxRotation, const Vector &vecOBBMins, 
                         const Vector &vecOBBMaxs, float flTolerance, trace_t &tr);
</code>

**Key Features**:
  * **Rotation Handling**: Accurately manages rotated entities by transforming collision queries into local space.
  * **Efficiency**: Maintains high performance even with complex, rotated collision models through optimized algorithms.

----

==== Collision Masks ====

Collision masks are predefined combinations of contents flags used to filter collision checks efficiently. They determine which types of surfaces should be considered during specific collision queries.

----

=== Mask Definitions ===

<code cpp>
#define MASK_ALL                (0xFFFFFFFF)
#define MASK_SOLID              (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define MASK_PLAYERSOLID        (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define MASK_NPCSOLID           (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define MASK_WATER              (CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME)
#define MASK_OPAQUE             (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE)
#define MASK_OPAQUE_AND_NPCS    (MASK_OPAQUE|CONTENTS_MONSTER)
#define MASK_BLOCKLOS           (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_BLOCKLOS)
#define MASK_BLOCKLOS_AND_NPCS  (MASK_BLOCKLOS|CONTENTS_MONSTER)
#define MASK_VISIBLE            (MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE)
#define MASK_VISIBLE_AND_NPCS   (MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE)
#define MASK_SHOT               (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)
#define MASK_SHOT_HULL          (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE)
#define MASK_SHOT_PORTAL        (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define MASK_SOLID_BRUSHONLY    (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE)
#define MASK_PLAYERSOLID_BRUSHONLY (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE)
#define MASK_NPCSOLID_BRUSHONLY (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
#define MASK_NPCWORLDSTATIC     (CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
#define MASK_SPLITAREAPORTAL    (CONTENTS_WATER|CONTENTS_SLIME)
#define MASK_CURRENT            (CONTENTS_CURRENT_0|CONTENTS_CURRENT_90|CONTENTS_CURRENT_180|CONTENTS_CURRENT_270|CONTENTS_CURRENT_UP|CONTENTS_CURRENT_DOWN)
#define MASK_DEADSOLID          (CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_GRATE)
</code>

**Purpose**: Streamline collision checks by focusing only on relevant surfaces, thereby improving performance.

**Customization**: Developers can define custom masks tailored to specific collision scenarios.

----

=== Practical Usage ===

Masks are used as parameters in collision functions to specify which types of surfaces should be considered during the collision check. For example, when performing a bullet trace, ''MASK_SHOT'' is used to ensure the bullet interacts with solid objects, monsters, and hitboxes but ignores non-relevant surfaces.

<code cpp>
// Example: Performing a bullet trace
Ray_t ray;
ray.Init(startPoint, endPoint);
trace_t traceResult;
CM_BoxTrace(ray, headnode, MASK_SHOT, false, traceResult);

// Handle the collision
if (traceResult.fraction < 1.0f) {
    ApplyDamage(traceResult);
    SpawnImpactEffect(traceResult.endpos, traceResult.plane.normal);
}
</code>

**Explanation**:
  * **Initialization**: Define a ray from the starting point to the end point.
  * **Trace Execution**: Perform the collision trace using ''MASK_SHOT'' to filter relevant surfaces.
  * **Collision Handling**: If a collision is detected (''fraction < 1.0f''), apply damage and spawn visual effects at the collision point.

----

==== Collision System Workflow ====

Understanding the workflow of the collision system is essential for effective utilization and debugging.

----

=== Initialization ===

When a map is loaded using ''CM_LoadMap'', the engine parses the BSP data, initializing collision models, brushes, and BSP trees. ''CCollisionBSPData'' sets up all necessary structures to represent the static environment.

**Steps**:
  * **Parse BSP Data**: Read and interpret BSP files to extract collision geometry.
  * **Initialize Structures**: Populate ''CCollisionBSPData'' with brushes, planes, nodes, and leaves.
  * **Integrate Displacements**: Set up displacement collision trees for deformable terrains.

----

=== Entity Setup ===

Each entity initializes its ''CCollisionProperty'', defining its collision bounds, solid type, and other relevant properties. This setup allows the engine to manage collisions on a per-entity basis effectively.

<code cpp>
void CCollisionProperty::Init(CBaseEntity *pEntity) {
    m_pOuter = pEntity;
    m_vecMins.Init();
    m_vecMaxs.Init();
    m_flRadius = 0.0f;
    m_triggerBloat = 0;
    m_usSolidFlags = 0;
    m_nSolidType = SOLID_NONE;
}
</code>

**Key Actions**:
  * **Set Bounds**: Define the entity's bounding boxes.
  * **Define Solid Type**: Assign the appropriate solid type based on the entity's behavior.
  * **Configure Spatial Partitioning**: Register the entity within the spatial partitioning system for optimized collision checks.

----

==== Collision Queries ====

When a collision check is required (e.g., player movement, bullet firing), the engine performs trace operations using the defined collision methods. These traces interact with the BSP trees and collision models to determine intersections.

**Process**:
  * **Trace Initialization**: Define the trace parameters (e.g., ray origin, direction, extents).
  * **BSP Traversal**: Traverse the BSP tree to identify potential collision candidates.
  * **Intersection Testing**: Perform precise intersection tests with brushes, displacements, and other collision representations.
  * **Result Compilation**: Aggregate the results to determine the final collision outcome.

----

=== Result Handling ===

The outcome of collision traces informs game logic, such as stopping movement, applying damage, or triggering events. The engine processes these results to update the game state accordingly.

**Common Responses**:
  * **Movement Adjustment**: Modify entity movement vectors to prevent clipping through obstacles.
  * **Damage Application**: Apply damage to entities hit by projectiles.
  * **Event Triggers**: Activate in-game events based on collision interactions (e.g., opening doors, breaking glass).

----

==== Optimization Techniques ====

The Source Engine employs several strategies to ensure collision detection remains performant, even in complex environments.

----

=== BSP Trees ===

**Binary Space Partitioning (BSP) Trees** are crucial for efficient collision detection. By recursively dividing the game world into convex regions, BSP trees allow the engine to quickly eliminate large sections of the environment from collision checks.

<code cpp>
struct cnode_t {
    cplane_t *plane;          // Splitting plane.
    int children[2];          // Child nodes; negative indices indicate leaf nodes.
};
</code>

**Advantages**:
  * **Efficient Traversal**: Collision queries can quickly navigate the BSP tree to focus on relevant regions.
  * **Memory Efficiency**: Organizes collision data hierarchically, reducing redundant storage.

**Traversal Example**:
  * **Collision Query**: A ray trace begins at the root node, testing against the splitting plane to determine which child nodes to traverse next.

----

=== Spatial Partitioning ===

**Spatial Partitioning** organizes entities within spatial bounds, allowing the engine to perform localized collision checks. This partitioning minimizes unnecessary collision tests by limiting queries to nearby entities.

<code cpp>
class CDirtySpatialPartitionEntityList : public IPartitionQueryCallback {
    void AddEntity(CBaseEntity *pEntity);
    void UpdatePartition();
    void CreatePartitionHandle();
    
private:
    CTSListWithFreeList<CBaseHandle> m_DirtyEntities;
    CThreadSpinRWLock m_partitionMutex;
};
</code>

**Features**:
  * **Thread-Safe Management**: Utilizes synchronization mechanisms to handle concurrent modifications.
  * **Dirty State Tracking**: Keeps track of entities that have moved or changed, ensuring the spatial partition is updated accordingly.
  * **Efficient Queries**: Enables quick retrieval of entities within specific spatial regions for collision checks.

**Benefits**:
  * **Performance**: Reduces the number of collision checks by focusing only on entities within relevant spatial partitions.
  * **Scalability**: Handles a large number of entities without significant performance hits.

----

=== Trace Caching ===

**Trace Caching** involves storing intermediate results during collision traces to prevent redundant calculations. Structures like ''TraceInfo_t'' keep track of visited brushes and displacement surfaces, optimizing repeated collision checks within the same trace.

**Functionality**:
  * **Visited Tracking**: Records which brushes and surfaces have been checked to avoid duplicate tests.
  * **Count Comparison**: Uses trace counters to determine if a brush has already been processed in the current trace.
    
**Impact**: Significantly improves performance in scenarios with multiple potential collision surfaces by eliminating unnecessary checks.

----

=== Bit Packing ===

**Bit Packing** optimizes memory usage by tightly encoding coordinate and normal data. Defined in ''coordsize.h'', bit packing ensures that positional data is compactly stored and efficiently transmitted over the network.

<code cpp>
#define COORD_INTEGER_BITS        14
#define COORD_FRACTIONAL_BITS     5
#define COORD_DENOMINATOR         (1 << COORD_FRACTIONAL_BITS)
#define COORD_RESOLUTION          (1.0 / (COORD_DENOMINATOR))
</code>

**Advantages**:
  * **Memory Efficiency**: Reduces the amount of memory required to store positional data.
  * **Network Optimization**: Minimizes bandwidth usage by compactly representing coordinates in network messages.
    
**Implementation**:
  * **Coordinate Limits**: Defines the range and precision of coordinates based on bit allocation.
  * **Consistency Checks**: Ensures that ''coordsize.h'' and ''worldsize.h'' are aligned to prevent mismatches.

**Considerations**:
  * **Precision vs. Range**: Balances the number of integer bits (range) and fractional bits (precision) to suit different use cases.
  * **Client-Server Synchronization**: Maintains consistent coordinate representation across client and server to prevent discrepancies in collision detection.

----

=== SIMD-Optimized Collision Tests ===

The Source Engine heavily utilizes **SIMD (Single Instruction, Multiple Data)** instructions for performance-critical collision tests. SIMD allows parallel processing of multiple data points, significantly enhancing the speed of collision detection algorithms.

----

==== Advanced Topics ====

Delving deeper into the collision system reveals more complex and nuanced aspects that enhance its functionality and performance.

----

=== Content Type System ===

The **Content Type System** organizes contents in a hierarchical structure, allowing for flexible and prioritized collision interactions.

----

=== Hierarchical Content Organization ===

Contents are organized in a hierarchy of precedence to manage collision behaviors effectively.

**Base Contents**:
  * ''CONTENTS_EMPTY'' (0x0): Represents no collision.
  * ''CONTENTS_SOLID'' (0x1): Defines completely solid objects.
  * ''CONTENTS_WINDOW'' (0x2): Represents translucent surfaces like glass.

**Fluid Contents**:
  * ''CONTENTS_WATER'' (0x20): Defines water areas affecting movement and physics.
  * ''CONTENTS_SLIME'' (0x10): Represents slippery surfaces with low friction.

**Special Contents**:
  * ''CONTENTS_HITBOX'' (0x40000000): Used for precise hit detection on entities.
  * ''CONTENTS_MONSTER'' (0x2000000): Represents monsters, affecting AI collision behavior.

<code cpp>
// Example of content inheritance
if (contents & CONTENTS_SOLID) {
    // Handle solid collision
    if (contents & CONTENTS_WINDOW) {
        // Special case for window surfaces
    }
}
</code>

**Content Hierarchy Explanation**:
  * **Priority Management**: Base contents have lower precedence, while specialized contents can override or extend base behaviors.
  * **Flexible Interaction**: Allows for complex collision interactions by combining multiple content flags.

----

=== Content Inheritance ===

Content inheritance enables entities and surfaces to have layered collision behaviors by combining multiple content flags.

<code cpp>
// Example of content inheritance
if (contents & CONTENTS_SOLID) {
    // Handle solid collision
    if (contents & CONTENTS_WINDOW) {
        // Special case for window surfaces
    }
}
</code>

**Use Cases**:
  * **Composite Surfaces**: Surfaces like windows are both ''CONTENTS_SOLID'' and ''CONTENTS_WINDOW'', allowing for unique collision responses (e.g., bullets pass through but players cannot).
  * **Dynamic Behavior**: Combining content flags enables entities to change collision behaviors based on game events (e.g., opening a door changes its contents flags).

**Advantages**:
  * **Modularity**: Simplifies the management of complex collision behaviors by layering simple flags.
  * **Scalability**: Easily extends to accommodate new content types and behaviors without overhauling the entire system.

----

==== Displacement Collision System ====

The **Displacement Collision System** handles collisions with deformable terrains, ensuring accurate interactions with dynamic and varied surfaces.

----

==== CDispCollTree Implementation ====

Displacements use a specialized collision tree for efficient intersection testing, combining broad-phase and narrow-phase collision detection.

<code cpp>
class CDispCollTree {
public:
    bool AABBTree_Ray(const Ray_t &ray, const Vector &invDelta, trace_t *pTrace);
    bool AABBTree_SweepAABB(const Ray_t &ray, const Vector &invDelta, trace_t *pTrace);
    
    // Triangle collision data
    Vector m_mins;           // AABB mins
    Vector m_maxs;           // AABB maxs
    int m_power;            // Subdivision power
    int m_contents;         // Surface contents
    unsigned short m_surfaceProps[2]; // Surface properties
};
</code>

**Key Features**:
  * **Hierarchical AABB Tree**: Facilitates efficient broad-phase collision detection by organizing displacement collision data hierarchically.
    
  * **Triangle Collision**: Implements precise collision detection using detailed triangle meshes within displacements.
    
  * **Surface Property Support**: Allows each displacement triangle to have unique surface properties, affecting physical interactions like friction and restitution.

**Functions**:
  * **AABBTree_Ray**: Performs ray intersection tests within the displacement's AABB tree.
  * **AABBTree_SweepAABB**: Conducts swept AABB collision checks for dynamic interactions.

**Benefits**:
  * **Efficiency**: Combines broad-phase and narrow-phase collision detection to minimize computational overhead.
  * **Precision**: Ensures accurate collision responses on complex, deformable terrains.

----

==== Spatial Partition System ====

The **Spatial Partition System** organizes entities and collision data into spatial regions, enhancing the efficiency of collision queries and rendering.

----

=== Partition Management ===

<code cpp>
class CDirtySpatialPartitionEntityList : public IPartitionQueryCallback {
    void AddEntity(CBaseEntity *pEntity);
    void UpdatePartition();
    void CreatePartitionHandle();
    
private:
    CTSListWithFreeList<CBaseHandle> m_DirtyEntities;
    CThreadSpinRWLock m_partitionMutex;
};
</code>

**Features**:
  * **Thread-Safe Entity Management**: Ensures that spatial partition updates are safe in multi-threaded environments using synchronization primitives like spin locks.
  * **Dirty State Tracking**: Maintains a list of entities that have moved or changed, indicating which partitions need updating.
  * **Efficient Spatial Queries**: Implements callback mechanisms to efficiently retrieve entities within specific spatial regions during collision checks.

**Implementation Details**:
  * **AddEntity**: Adds entities to the dirty list for partition updates.
  * **UpdatePartition**: Processes the dirty list, updating spatial partitions as necessary.
  * **CreatePartitionHandle**: Assigns unique handles to entities for quick lookup and management within the spatial partition system.

**Benefits**:
  * **Performance**: Reduces the computational load by limiting collision checks to relevant spatial regions. 
  * **Scalability**: Supports a large number of entities without compromising performance by efficiently managing spatial data.

**Integration with Collision System**:
  * **Entity Registration**: Entities are registered within the spatial partition system during initialization and entity setup.
  * **Collision Query Optimization**: Collision queries reference the spatial partition to quickly identify potential collision candidates, avoiding exhaustive checks across all entities.

----

==== Conclusion ====

The **Source Engine's Collision System** is a sophisticated blend of data structures, algorithms, and optimizations designed to handle a wide array of collision scenarios efficiently and accurately. By leveraging BSP trees for spatial partitioning, various collision representations for different entity types, and optimized tracing methods, the system ensures both performance and precision. Understanding these components empowers developers to create immersive and responsive gameplay experiences within the Source Engine framework.

**Key Takeaways**:
  * **Modular Design**: The collision system's modular architecture allows for flexibility and scalability.
  * **Performance Optimization**: Employs advanced techniques like BSP trees, spatial partitioning, trace caching, and SIMD optimizations to maintain high performance.
  * **Precision and Flexibility**: Supports a wide range of collision types, from simple bounding boxes to complex, deformable terrains and dynamic physics interactions.

By mastering the components and workflows of the collision system, developers can effectively utilize and extend the Source Engine to build rich and interactive game worlds.

----

==== References ====

  * [[https://developer.valvesoftware.com/wiki/Source_SDK|Source SDK Documentation]]
  * [[https://github.com/lua9520/source-engine-2018-hl2_src|Source Engine Code]]
  * [[https://developer.valvesoftware.com/wiki/Collision|Valve Developer Community: Collision]]
  * [[https://en.wikipedia.org/wiki/Binary_space_partitioning|Binary Space Partitioning (BSP) Trees]]
  * [[https://developer.valvesoftware.com/wiki/VPhysics|VPhysics Overview]]
  * [[https://en.wikipedia.org/wiki/SIMD|SIMD Math Optimizations]]
  * [[https://developer.valvesoftware.com/wiki/Contents|Content Flags and Masks]]
